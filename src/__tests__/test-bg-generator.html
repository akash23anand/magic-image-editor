<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BG Generator Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .test-case {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        canvas {
            border: 1px solid #ddd;
            max-width: 100%;
            height: auto;
            display: block;
            margin: 10px 0;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 14px;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        input[type="text"] {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>BG Generator End-to-End Test</h1>
    
    <div class="controls">
        <h3>Test Controls</h3>
        <input type="file" id="imageInput" accept="image/*">
        <input type="text" id="promptInput" placeholder="Enter background prompt (e.g., 'blue sky with clouds')" value="blue sky with clouds">
        <button onclick="runAllTests()">Run All Tests</button>
        <button onclick="testFallbackOnly()">Test Fallback Only</button>
        <button onclick="testWithAPI()">Test with API</button>
    </div>

    <div id="status" class="status info">Ready to test</div>

    <div class="container" id="results"></div>

    <script type="module">
        // Import the services
        import { unifiedAIService } from '../services/UnifiedAIService.js';
        import { stableDiffusionService } from '../services/StableDiffusionService.js';
        
        window.unifiedAIService = unifiedAIService;
        window.stableDiffusionService = stableDiffusionService;

        let testImage = null;

        // Create a test image
        function createTestImage() {
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            
            // Draw a simple test image
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw a red rectangle in the center
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(150, 100, 100, 100);
            
            // Add some text
            ctx.fillStyle = '#000000';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Test Image', 200, 50);
            
            return ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        // Load image from file input
        document.getElementById('imageInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async (event) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    testImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    updateStatus('Image loaded successfully', 'success');
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        function updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            console.log(`[${type}] ${message}`);
        }

        function displayResult(title, originalImage, processedImage, metadata) {
            const container = document.getElementById('results');
            const testCase = document.createElement('div');
            testCase.className = 'test-case';
            
            testCase.innerHTML = `
                <h3>${title}</h3>
                <div class="comparison">
                    <div>
                        <h4>Original</h4>
                        <canvas id="original-${Date.now()}"></canvas>
                    </div>
                    <div>
                        <h4>Processed</h4>
                        <canvas id="processed-${Date.now()}"></canvas>
                    </div>
                </div>
                <pre>${JSON.stringify(metadata, null, 2)}</pre>
            `;
            
            container.appendChild(testCase);
            
            // Draw original
            const originalCanvas = testCase.querySelector('canvas[id^="original"]');
            originalCanvas.width = originalImage.width;
            originalCanvas.height = originalImage.height;
            originalCanvas.getContext('2d').putImageData(originalImage, 0, 0);
            
            // Draw processed
            const processedCanvas = testCase.querySelector('canvas[id^="processed"]');
            processedCanvas.width = processedImage.width;
            processedCanvas.height = processedImage.height;
            processedCanvas.getContext('2d').putImageData(processedImage, 0, 0);
        }

        window.runAllTests = async function() {
            document.getElementById('results').innerHTML = '';
            const prompt = document.getElementById('promptInput').value;
            
            if (!testImage) {
                testImage = createTestImage();
            }
            
            updateStatus('Running all tests...', 'info');
            
            // Test 1: Current implementation (shows the issue)
            try {
                updateStatus('Testing current fallback implementation...', 'info');
                const result1 = await unifiedAIService.processImage('bg-generator', testImage, { prompt });
                displayResult('Current Implementation (Fallback)', testImage, result1.imageData, result1.metadata);
            } catch (error) {
                updateStatus(`Error in current implementation: ${error.message}`, 'error');
            }
            
            // Test 2: Fixed implementation
            try {
                updateStatus('Testing fixed implementation...', 'info');
                const fixedResult = await testFixedImplementation(testImage, prompt);
                displayResult('Fixed Implementation', testImage, fixedResult.imageData, fixedResult.metadata);
            } catch (error) {
                updateStatus(`Error in fixed implementation: ${error.message}`, 'error');
            }
            
            updateStatus('All tests completed', 'success');
        };

        window.testFallbackOnly = async function() {
            document.getElementById('results').innerHTML = '';
            const prompt = document.getElementById('promptInput').value;
            
            if (!testImage) {
                testImage = createTestImage();
            }
            
            try {
                updateStatus('Testing fallback background generator...', 'info');
                
                // Force fallback by temporarily breaking the API check
                const originalCheckHealth = stableDiffusionService.checkHealth;
                stableDiffusionService.checkHealth = async () => false;
                
                const result = await unifiedAIService.processImage('bg-generator', testImage, { prompt });
                displayResult('Fallback Background Generator', testImage, result.imageData, result.metadata);
                
                // Restore original function
                stableDiffusionService.checkHealth = originalCheckHealth;
                
                updateStatus('Fallback test completed', 'success');
            } catch (error) {
                updateStatus(`Error: ${error.message}`, 'error');
            }
        };

        window.testWithAPI = async function() {
            document.getElementById('results').innerHTML = '';
            const prompt = document.getElementById('promptInput').value;
            
            if (!testImage) {
                testImage = createTestImage();
            }
            
            try {
                updateStatus('Checking Stable Diffusion API...', 'info');
                const isHealthy = await stableDiffusionService.checkHealth();
                
                if (!isHealthy) {
                    updateStatus('Stable Diffusion API is not available. Please ensure it is running on http://localhost:7860', 'error');
                    return;
                }
                
                updateStatus('Testing with Stable Diffusion API...', 'info');
                const result = await unifiedAIService.processImage('bg-generator', testImage, { prompt });
                displayResult('Stable Diffusion API Result', testImage, result.imageData, result.metadata);
                
                updateStatus('API test completed', 'success');
            } catch (error) {
                updateStatus(`Error: ${error.message}`, 'error');
            }
        };

        // Fixed implementation that properly generates a background
        async function testFixedImplementation(imageData, prompt) {
            const canvas = document.createElement('canvas');
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            const ctx = canvas.getContext('2d');
            
            // First, draw the gradient background
            const promptLower = prompt.toLowerCase();
            const colors = extractColorsFromPrompt(promptLower);
            
            let gradient;
            if (promptLower.includes('radial')) {
                gradient = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, 0,
                    canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) / 2
                );
            } else {
                gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            }
            
            colors.forEach((color, index) => {
                gradient.addColorStop(index / (colors.length - 1), color);
            });
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Now extract the subject from the original image (simple threshold-based)
            const subjectCanvas = document.createElement('canvas');
            subjectCanvas.width = imageData.width;
            subjectCanvas.height = imageData.height;
            const subjectCtx = subjectCanvas.getContext('2d');
            subjectCtx.putImageData(imageData, 0, 0);
            
            // Get the subject with transparency (simple white background removal)
            const subjectImageData = subjectCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = subjectImageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Simple white background detection
                if (r > 240 && g > 240 && b > 240) {
                    data[i + 3] = 0; // Make transparent
                }
            }
            
            subjectCtx.putImageData(subjectImageData, 0, 0);
            
            // Draw the subject on top of the new background
            ctx.drawImage(subjectCanvas, 0, 0);
            
            const resultImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            return {
                imageData: resultImageData,
                metadata: {
                    model: 'Fixed Background Generator',
                    prompt: prompt,
                    note: 'This shows how the background should be replaced',
                    colors: colors
                }
            };
        }

        function extractColorsFromPrompt(prompt) {
            const colorMap = {
                'sky': ['#87CEEB', '#E0F6FF', '#FFFFFF'],
                'blue': ['#1e3c72', '#2a5298', '#7e8ba3'],
                'sunset': ['#ff7e5f', '#feb47b', '#ffcd94'],
                'nature': ['#134e5e', '#71b280', '#a8e6cf'],
                'forest': ['#134e5e', '#71b280', '#a8e6cf'],
                'ocean': ['#1a2980', '#26d0ce', '#7de2fc'],
                'purple': ['#667eea', '#764ba2', '#f093fb'],
                'pink': ['#ff9a9e', '#fecfef', '#fecfef'],
                'warm': ['#ffecd2', '#fcb69f', '#ff9a9e'],
                'cool': ['#a8edea', '#fed6e3', '#d299c2'],
                'dark': ['#2c3e50', '#34495e', '#7f8c8d'],
                'black': ['#000000', '#434343', '#666666'],
                'white': ['#ffffff', '#f8f9fa', '#e9ecef'],
                'gradient': ['#667eea', '#764ba2', '#f093fb'],
            };

            for (const [keyword, colors] of Object.entries(colorMap)) {
                if (prompt.includes(keyword)) {
                    return colors;
                }
            }

            return ['#f0f0f0', '#e0e0e0', '#d0d0d0'];
        }

        // Initialize with test image
        window.onload = () => {
            testImage = createTestImage();
            updateStatus('Test image created. You can also upload your own image.', 'success');
        };
    </script>
</body>
</html>